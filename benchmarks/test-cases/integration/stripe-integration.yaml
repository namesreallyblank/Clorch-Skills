# Stripe Integration Skill Benchmark Tests
# Tests the skill's ability to catch real Stripe gotchas

skill: stripe-integration
category: integration
skill_path: integration/stripe-integration

metadata:
  priority: critical
  complexity: high
  sharp_edges_count: 15
  last_updated: 2025-12-30

# ==============================================================================
# OPEN-ENDED TESTS - Holistic skill application
# ==============================================================================

tests:
  # --------------------------------------------------------------------------
  # Test 1: Full subscription system implementation
  # --------------------------------------------------------------------------
  - id: stripe-open-01
    type: open-ended
    name: "Build subscription billing system"
    difficulty: hard

    prompt: |
      Build a complete Stripe subscription billing system for a SaaS app.

      Requirements:
      - 3 pricing tiers: Starter ($10/mo), Pro ($50/mo), Enterprise ($200/mo)
      - Support monthly and annual billing (20% discount for annual)
      - Handle subscription upgrades/downgrades with proration
      - Webhook handling for all subscription lifecycle events
      - Customer portal for self-service billing management
      - Store subscription status in PostgreSQL database
      - Handle failed payments with dunning (retry logic)

      Tech stack: Next.js API routes, PostgreSQL, TypeScript

      Provide the complete implementation with all necessary files.

    evaluation_criteria:
      - Stripe signature verification on webhooks
      - Idempotency keys for mutation operations
      - Proper proration handling for plan changes
      - All webhook events handled (created, updated, deleted, payment_failed)
      - Customer portal session creation
      - Database schema for subscriptions
      - Error handling with specific Stripe error types
      - Environment variable handling for keys
      - Test mode vs live mode awareness

    weight: 2.0  # Double weight - comprehensive test

  # --------------------------------------------------------------------------
  # Test 2: One-time payment flow
  # --------------------------------------------------------------------------
  - id: stripe-open-02
    type: open-ended
    name: "Implement one-time payment"
    difficulty: medium

    prompt: |
      Implement a one-time payment flow for selling digital products.

      Requirements:
      - Product: Premium Template Bundle ($49)
      - Use Stripe Checkout for payment
      - Send download link via email after successful payment
      - Store purchase record in database
      - Handle refunds

      Use Next.js API routes and include webhook handling.

    evaluation_criteria:
      - Checkout session with correct line items
      - Webhook for checkout.session.completed
      - Email trigger on successful payment
      - Refund webhook handling (charge.refunded)
      - Success/cancel URL handling
      - Metadata for tracking purchases

# ==============================================================================
# TRAP TESTS - Target specific sharp edges
# ==============================================================================

  # --------------------------------------------------------------------------
  # Trap 1: Webhook race condition (most common production bug)
  # --------------------------------------------------------------------------
  - id: stripe-trap-01
    type: trap
    name: "Webhook race condition"
    difficulty: hard
    sharp_edge: webhook-race-condition

    prompt: |
      Users report their subscription status is sometimes wrong after payment.
      About 5% of new subscribers show as "inactive" even though payment succeeded.

      Here's our webhook handler:

      ```typescript
      // app/api/webhooks/stripe/route.ts
      import Stripe from 'stripe';

      const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!);

      export async function POST(req: Request) {
        const body = await req.text();
        const sig = req.headers.get('stripe-signature')!;

        const event = stripe.webhooks.constructEvent(
          body,
          sig,
          process.env.STRIPE_WEBHOOK_SECRET!
        );

        if (event.type === 'checkout.session.completed') {
          const session = event.data.object as Stripe.Checkout.Session;

          await prisma.user.update({
            where: { email: session.customer_email! },
            data: {
              subscriptionStatus: 'active',
              customerId: session.customer as string
            }
          });
        }

        return Response.json({ received: true });
      }
      ```

      What's causing the 5% failure rate? How do we fix it?

    expected_detection:
      must_identify:
        - "Race condition: checkout.session.completed fires before user record exists for new signups"
        - "Missing idempotency: duplicate webhooks can cause issues"
        - "Should handle subscription.created/updated, not just checkout.session.completed"
        - "No error handling if user not found"

      must_recommend:
        - "Use customer.subscription.created for subscription status"
        - "Add idempotency check using event.id"
        - "Handle case where user doesn't exist yet"
        - "Use database transactions"

    trap_code_issues:
      - line: 15
        issue: "checkout.session.completed is not reliable for subscription status"
      - line: 17-22
        issue: "No check if user exists, no idempotency, no transaction"

  # --------------------------------------------------------------------------
  # Trap 2: Missing signature verification
  # --------------------------------------------------------------------------
  - id: stripe-trap-02
    type: trap
    name: "Security vulnerability - missing verification"
    difficulty: medium
    sharp_edge: webhook-security

    prompt: |
      I'm getting webhook errors in production. I simplified the handler to fix it:

      ```typescript
      export async function POST(req: Request) {
        const event = await req.json();

        if (event.type === 'invoice.paid') {
          await prisma.subscription.update({
            where: { stripeSubId: event.data.object.subscription },
            data: { status: 'active' }
          });
        }

        return Response.json({ received: true });
      }
      ```

      Now webhooks work fine. Is this okay for production?

    expected_detection:
      must_identify:
        - "CRITICAL: No signature verification - anyone can fake webhooks"
        - "Attacker can set any subscription to 'active' by sending fake events"
        - "This is a security vulnerability, not a fix"

      must_recommend:
        - "Always use stripe.webhooks.constructEvent()"
        - "Never trust webhook body without signature verification"
        - "Return 400 for invalid signatures"

    severity: critical

  # --------------------------------------------------------------------------
  # Trap 3: Subscription status sync issues
  # --------------------------------------------------------------------------
  - id: stripe-trap-03
    type: trap
    name: "Status sync with trials"
    difficulty: hard
    sharp_edge: trial-status-confusion

    prompt: |
      We offer a 14-day trial. Users complain they lose access on day 1.

      Here's how we check subscription status:

      ```typescript
      async function hasActiveSubscription(userId: string) {
        const user = await prisma.user.findUnique({
          where: { id: userId },
          include: { subscription: true }
        });

        return user?.subscription?.status === 'active';
      }
      ```

      And our webhook updates status like this:

      ```typescript
      if (event.type === 'customer.subscription.created') {
        const sub = event.data.object as Stripe.Subscription;
        await prisma.subscription.create({
          data: {
            stripeSubId: sub.id,
            userId: sub.metadata.userId,
            status: sub.status,  // This is 'trialing', not 'active'!
          }
        });
      }
      ```

      Why are trial users locked out?

    expected_detection:
      must_identify:
        - "Trial subscriptions have status 'trialing', not 'active'"
        - "hasActiveSubscription() only checks for 'active'"
        - "Need to accept both 'active' AND 'trialing' as valid"

      must_recommend:
        - "Check for status in ['active', 'trialing']"
        - "Or store a separate 'hasAccess' boolean"
        - "Handle trial_end date for trial expiry warnings"

  # --------------------------------------------------------------------------
  # Trap 4: Proration confusion
  # --------------------------------------------------------------------------
  - id: stripe-trap-04
    type: trap
    name: "Upgrade proration surprise"
    difficulty: medium
    sharp_edge: proration-unexpected-charges

    prompt: |
      Users upgrading from Starter ($10) to Pro ($50) mid-cycle are charged
      the full $50 immediately, then another $50 at the next billing date.
      They're complaining about being "double charged."

      Here's our upgrade code:

      ```typescript
      async function upgradeSubscription(subId: string, newPriceId: string) {
        await stripe.subscriptions.update(subId, {
          items: [{
            id: (await stripe.subscriptions.retrieve(subId)).items.data[0].id,
            price: newPriceId,
          }],
        });
      }
      ```

      How do we fix the double-charge issue?

    expected_detection:
      must_identify:
        - "Default proration behavior charges immediately for upgrade difference"
        - "User expects prorated credit, gets full charge"
        - "Need to set proration_behavior explicitly"

      must_recommend:
        - "Use proration_behavior: 'create_prorations' for fair proration"
        - "Or 'none' to delay until next cycle"
        - "Communicate proration clearly to users before upgrade"
        - "Show preview with upcoming_invoice endpoint"

# ==============================================================================
# DECISION TESTS - Strategic choices
# ==============================================================================

  # --------------------------------------------------------------------------
  # Decision 1: Checkout vs Elements
  # --------------------------------------------------------------------------
  - id: stripe-decision-01
    type: decision
    name: "Checkout vs Custom Payment Form"
    difficulty: medium

    prompt: |
      We're building a B2B SaaS for project management. Need to decide on
      payment implementation.

      Context:
      - 2-person engineering team
      - Launch deadline: 3 weeks
      - 3 pricing tiers ($29, $99, $299/mo per seat)
      - Need to collect: company name, VAT ID, billing address
      - Target market: EU companies (VAT compliance matters)
      - Want branded experience

      Options:
      A) Stripe Checkout (hosted payment page)
      B) Stripe Elements (embedded custom form)
      C) Payment Links (no-code)

      Which should we choose and why?

    expected_reasoning:
      should_recommend: "A) Stripe Checkout"

      key_points:
        - "3 weeks + 2-person team = no time for custom Elements implementation"
        - "Checkout handles PCI compliance automatically"
        - "Custom fields API supports company name, VAT ID collection"
        - "Checkout has built-in EU VAT validation and collection"
        - "Customer portal handles subscription management"
        - "Branded experience possible with Checkout customization"

      should_warn:
        - "Redirect experience (but acceptable for B2B)"
        - "Limited UI customization (but sufficient for launch)"
        - "Can migrate to Elements later if needed"

      wrong_if:
        - "Recommends Elements without acknowledging time/complexity tradeoff"
        - "Ignores VAT compliance requirements"
        - "Suggests Payment Links for subscription business"

  # --------------------------------------------------------------------------
  # Decision 2: Metered vs Licensed billing
  # --------------------------------------------------------------------------
  - id: stripe-decision-02
    type: decision
    name: "Billing model selection"
    difficulty: hard

    prompt: |
      Building an AI writing tool. Need to decide billing model.

      Product details:
      - Users generate AI content (blog posts, emails, etc.)
      - Average user generates 50-200 pieces/month
      - Some power users generate 1000+/month
      - API costs us ~$0.02 per generation

      Options:
      A) Flat monthly subscription tiers ($20, $50, $100)
      B) Usage-based (pay per generation, e.g., $0.10 each)
      C) Hybrid (base subscription + overage charges)

      What's the right billing model?

    expected_reasoning:
      should_recommend: "C) Hybrid model"

      key_points:
        - "Flat tiers leave money on table from power users"
        - "Pure usage-based has unpredictable revenue"
        - "Hybrid gives predictable base + captures power user value"
        - "Include generous base allocation to reduce friction"
        - "Stripe metered billing supports this model"

      implementation_notes:
        - "Use licensed quantity for base tier"
        - "Use metered billing for overages"
        - "Report usage via meter events API"

# ==============================================================================
# SCORING WEIGHTS
# ==============================================================================

scoring:
  dimensions:
    correctness: 25
    completeness: 25
    expertise: 25
    gotcha_awareness: 25

  passing_thresholds:
    overall_score: 85
    win_rate: 75
    trap_detection: 80

  category_weights:
    open-ended: 1.0
    trap: 1.5  # Trap tests weighted higher - this is our differentiator
    decision: 1.0
